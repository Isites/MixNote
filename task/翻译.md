> #Leveraging adjusted user behavior in the detection and prevention of outgoing malicious SMSs in Android devices

#在Android设备上通过检测用户的行为，来调整预防发出恶意短信

> Abstract: In this paper, we propose OnDroid, a prevention system to defend against outgoing malicious SMS in Android devices. OnDroid is user-friendly as it considers the user's little understanding of the Android system. It also considers multiple threat scenarios and requires less interaction with the user. For each SMS-sending operation , OnDroid first checks if the mobile device state mismatches the user's behavior. If so, the operation is blocked. Otherwise, it is delayed for a while and the user is notified to confirm or reject the operation. If the SMS is considered normal, the user does not need to take any action and the SMS is sent when the delay expires. Efficiency analysis shows that malicious SMS operations might be missed when the user is unavailable. To  deal with this issue, we propose a method by which the user behavior can be adjusted to achieve 100% of malicious SMS prevention. Formal analysis as well as comparative study show that OnDroid offers a good tradeoff between security efficiency and usability.

摘要：在本文中，我们提出了一个Android设备上的、可以防止发出恶意短信的防御系统，并命名为OnDroid。OnDroid 是用户友好的，因为它不仅考虑了用户对Android系统知之甚少，而且考虑了多种和用户交互较少的威胁场景。每次发送短信时，OnDroid 首先检查移动设备的状态是否符合用户行为，如果不符合，则阻塞发送。否则，短信发送将被延迟并通知用户，让用户来确认或者拒绝该操作。如果短信被认为是正常的，则用户不需要采取任何行动，至到延时结束后短信将被发送。`效益分析表明，当用户不可用的时候，发送恶意短信可能会被错过。为了解决这个问题 我们提出了一个方法，通过调整用户的行为，来实现100%的防范恶意短信。正式的分析和比较表明，OnDroid 在安全性和易用性之间取得了良好的平衡。`

> Introduction: The Android operating system is largely popular among mobile device users. According to some several reports (Mawston, July 2014; http://www.idc.com/prodse), Android dominated the Smartphone market with a share of 85% and 82.8% in the second quarter of 2014 and 2015 respectively. Due to this popularity, it has been highly targeted by malware developers, which aim at profiting financially by infecting a large number of mobile devices. A study (Maslennikov, February 2014) has shown that Android acounts for 98.05% of mobile threats. According to F-secure report (Labs, April 2014), 99% of the emerged threats, which were discovered in the first quarter of 2014, were designed to run on the Android operating system. F-secure also reported in 2013 that 81.1% of the mobile malware were financially-motivated and 97.14% of the latter targeted Android OS (Labs, November 2013). Most of the financially-motivated malware perform SMS-sending activities during their attacks. This fact was supported by a report published in 2014 (Labs, April 2014). The report showed that 83% of the Android malwares analyzed by F-secure were performing SMS-sending activities, also called SMS-based attacks. These attacks are charged to the victims's account without his/her consent or knowledge, and can take the following forms:

引言：Android操作系统在移动设备用户中广泛流行。据几份报告(Mawston，2014年7月；http://www.idc.com/prodse)显示，Android在智能手机市场占据主导地位，在2014和2015年的第二季度其市场份额分别为85%和82.8%。归咎于其流行程度，Android 平台    。一项研究(Maslennikov，2014年2月)表明，Android占据移动设备威胁的98.05%。F-secure公司报告(Labs，2014年4月)称，2014年第一季度发现的威胁中，99%为Android操作系统设计的。F-secure公司还报告称，在恶意软件中，81.1%是以金钱为动机的，其97.14%的目标是Android系统(Labs，2013年11月)。大部分的恶意软件通过发送短信来进行攻击行为。这一事实的有力支撑者是一篇2014年刊登的报告（Labs，2014年4月）。该报告显示，F-secure分析的Android 恶意软件中，83%表现为发送短信，也称为基于短信的攻击。这些攻击在没有用户的同意或了解的情况下就得到受害者的账户信息。其攻击方式可以采取以下几种方式：

> * SMS Spam: It is an unsolicited message sent from the compromised mobile device to advertise goods and products. The spammers send instructions to the compromised devices to launch SMS spam campaigns(Cloudmark, March 2014).
>
> * SMS Premium rate fraud: The malware sends an SMS to a premium rate number, which results in transferring costly sums from the user's account to that of the cybercriminal(Labs, April 2014).
>
> * SMS malware propagation: The malware sends an SMS containing links to malicious applications in order to infect the recipient devices.
>
> * SMS privacy attack: Some malware secretly send through SMS sensitive information stored at the device to the attacker such as: bank account, phone identifiers (IMES, IMSI), and GPS location.
>
> * SMS flooding attack: Many unauthorized SMSs are generated to attack a target, which might lead to a Denial-of-Service(Dos) (Traynor et al., 2009)
>
>   ​

垃圾短信：受感染的移动设备会在未经许可的情况下发送短信来宣传一些产品。垃圾短信的控制者发送指令到受感染的设备上，以此来启动和发送垃圾短信(Cloudmark，2014年3月)。


收费短信诈骗：恶意软件发送短信到一个需要收费的号码，这将从用户账户中转走大量资金，从而构成网络犯罪(Labs，2014年4月)。


传播恶意短信：恶意软件发送一条包含有链接到恶意应用的链接的短信，从而感染接受设备。


隐私攻击短信：一些恶意软件通过短信偷偷发送一些存储在用户设备上的敏感信息。例如：银行账户，手机表示(IMES, IMSI)，和位置信息。


短信轰炸：生成很多未经授权的短信去攻击一个目标，而导致服务不可用。(Traynor等，2009)。

> The applications in Android use APIs to access resources such as: telephony, SMS and other network functions. These APIs are protected through a security mechanism called permissions. The application developer must define the list of requested permissions in the AndroidManifest.xml file. To complete the installation process of hte applicaton, the user must grant all the requested permissions. Otherwise, the installations fails. In Android 4.2 (Jelly Bean), when an application tries to send an SMS to a premium-rate number, the user is notified. However, a malware can hide the notification from the user. Starting from Android 4.4 (KitKat), the user has to select only default SMS applications, which is allowed to write to SMS provider and receive SMSs. The other SMS applications can only read the SMS provider and are notified when an SMS is received. However, this configuration cannot completely prevent the SMS attacks. It has been reported in(Labs, April 2014) that 0.1% of the applications, which are received from Google's Play Store, were found malicious. Therefore, a user might download a compromised SMS application that sends both legitimate and malicious SMSs. If the user selects it as default, the malicious SMSs cannot be detected as they cannot be distinguished from the legitimate ones.

Android 应用程序使用api来访问资源，例如：电话、短信和其他网络功能。这些api通过名为权限的安全机制而得到保护。Android应用程序的开发者必须在AndroidManifest.xml 文件中定义需要请求的权限列表。在应用程序的安装过程中，用户必须授予应用程序所请求的权限，否则会安装失败。在Android 4.2(Jelly Bean)中，当一个应用程序试图发送一条短信到需要收费的号码时，用户会得到提醒。但是恶意软件可以隐藏用户的通知。从搭载Android 4.4 开始(KitKat)开始，用户必须选择默认的短信应用，该应用拥有发送短信给短信提供商和接受短信的权限。其他短信应用程序只能读取短信的提供商，并在收到短信的时候得到提示。然而，这种形式任然不能完全防止短信攻击。据报道(Labs，2014年4月)，从谷歌应用商店下载的应用程序中，其中0.1% 被发现具有恶意行为。因此，用户可能下载一个既可以发送合法短信又可以发送恶意短信的折中型应用。如果用户把它选择作为默认应用，则会因为不能区分是恶意短信还是合法短息，而检测不到恶意短信。

> Most of the users have little understanding and knowledge of the Android permission policy. This was confirmed in a survey(Felt et al., 2012), which showed that only 17% of the users look at the requested permissions when installing applications. It has also been observed that developers request more permissions than they actually require(Felt, Chin Hanna, Song, & Wagner, 2011). As legitimate and malicious applications can request the same types of permissions, it is often difficult for the users to determine during the installation process if the requested permissions are harmful or not. To deal with this issue, many complementary security mechanisms have been proposed to detect or prevent malicious activities. These mechanisms offer different levels of security efficiency and different user interaction durations, and sometimes require users to have some knowledge of Android secuity.

大多数用户都对Android的权限策略知之甚少。这已经在一项调查中被证实(Feltd等，2012)，该项调查表明，在安装应用程序时，只有17%的用户会查看应用程序申请的权限。人们还发现，开发者请求的权限比他们实际需要的权限多(Felt，Chin Hanna，Song，& Wagner，2011)。因此合法的和不合法的应用程序的权限请求可能是一致的。所以，用户在应用程序的安装过程中，难以决定其申请的权限是有害的还是无害的。为了处理这个问题，很多互补的安全机制被提出来以检测 和阻止恶意活动。这些安全机制提供不同级别的安全效率和不同的用户交互持续时间，有些时候还需要用户具有一定的Android 相关的安全知识。

> In order to help the user to accurately distinguish between legitimate and malicious SMS applications, we propose OnDroid, a prevention system against outgoing malicious SMSs in Android devices. In this paper, we consider two types of SMS threats: (a) SMSs generated by a malicious application without the users knowledge, and (b) a compromised SMS application that sends both legitimate and malicious SMSs. The main idea of OnDroid is to find any incoherence (or mismatch) between the user behavior and the Android device state.

为了帮助用户准确区分合法和恶意短信应用程序，我们提出了OnDroid。它是一个针对Android设备的防止发送恶意短信的短信防御系统。在本文中，我们考虑两种类型的短信威胁：(a) 未经用户同意，有恶意应用生成的短信，和(b) 即可以发送合法和恶意短信的折中型短信应用。OnDroid的主要方案是，在用户行为和Android设备状态之间找出任意的不相关性(或者不匹配)。

> The main contributions of the paper are as follows:
>
> 1. We determine the main features of the user behavior with respect to the mobile device.
> 2. We identify the main features characterizing the Android device state.
> 3. We propose an algorithm that detects any mismatches between the user behavior and the Android device state when performing SMS-sending operations. This algorithm can prevent the occurrence of the first SMS threat.
> 4. If a match is found, the user has to check that the SMS does not come from the second SMS threat. To do so, we delay the SMS-sending operation and the user is notified to intervene in case the SMS is malicious.
> 5. We analyze the resilience of OnDroid against attacks and evaluate its detection efficiency.
> 6. We propose adjustment rules for the user behavior in order to prevent 100% of malicious SMS operations.
> 7. We provide a comparative study that OnDroid offers a good tradeoff between security efficiency and usability.
>
> The rest of the paper is organized as follows. Section 2 discuses related work. In section 3, we present the system model. The detailed descriptions of OnDroid is given in section 4. Security analysis and efficiency anaysis are provided in section 5 and section 6 respectively. In section 7, we present a performance and usability study of security solutions against SMS malware. Finally, Section 8 concludes the paper with a summary of our contributions.

本文的主要工作如下：

1. 我们确定用户在使用移动设备的主要行为特征。
2. 我们识别的主要特征来描述Android设备的状态。
3. 我们提出了一个算法，可以在进行短信发送动作时，来检测用户行为和Android设备状态之间的任何不匹配。该算法能够在第一时间阻止短信威胁的发生。
4. 如果发现匹配点，用户必须检查短信是否来自第三方的威胁。要做到这一点，我们延迟短信发送操作，并通知用户来干预，从而防止恶意短信。
5. 我们分析OnDroid的的应变能力和抵御攻击的能力，并评估其检测效率。
6. 为了100%的防止恶意短信，我们提出了用户行为调整规则。
7. 我们提供了一份比较性的研究，改研究表明OnDroid在安全效率和易用性之间取得了一个良好的平衡。

本文的其余部分安排如下：第二节中谈论了相关工作。在第三节中，我们提出了系统模型。OnDroid详细描述在第四节给出。安全分析和效率分析在第五节和第六节。第七节中，我们针对恶意软件提出了一个可用性研究和性能的安全解决方案。最后，第八节中总结本文和我们提供的资料摘要。

##2. Related Work

> The main existing approaches to detect an installed SMS malware on an Android device can be categorized into: static analysis and dynamic analysis. In the static analysis approaches, the application static information (i.e., program syntax, structural properties), which are extracted from the source or the binary code, are used to check if the application contains malicious code. However, obfuscation techniques can be used to avoid detection. In the dynamic approaches, the application behavior is observed during its execution to detect if there are any inconsistencies with the normal behavior. The problem with this approach is its computational cost and the possibility of evading the detection.

现有的检测在Android设备上安装的恶意短信软件的方法主要分为静态分析和动态分析两类。在静态分析方法中，通过从源码或者二进制代码中提取该应用程序的静态信息(既，程序语法，结构属性)，然后检查是否含有恶意代码。然而，模糊技术可以避免检测。在动态方法中，应用程序在起执行过程中的行为一直处于被监视的状态，从而可以检测其是否有什么异常行为。这种方法的问题是它的计算成本和逃避检测的可能性。

> In anoter category of approaches, called policy enforcement, the behavior of a legitimate application is supposed to follow certain predefined rules. If  a rule violation is found, the application is considered as malicious. The policy enforcing approaches are divided into mitigating and preventive.
>
> The mitigating approach cannot prevent the attack but only detect it, as the rule violation can only be observed after the attack has been carried out. On the other hand, the preventive approach can prevent the occurrence of the attack.

被称为策略执行的另一类方法中，一个合法的应用程序的行为应该是遵循预定义的规则的。如果发现违反规则，则该应用程序被认为是恶意的。实施的办法的政策分为缓解和预防。

缓解方法不能阻止攻击但是能够检测恶意行为，因为攻击之后才能观察到违反的规则。另一方面，预防方法可以防止攻击的发生。

###2.1 Mitigating policy enforcement approach

> In DroidForce (Siegfried Rasthofer, Lovat, & Bodden, 2014), policies are enforced on Android applications in order to deal with the SMS premium rate fraud and data leakage. However, not all policies can prevent the attacks. For example, one policy could state that "no more than two premium-rate messages per day might be sent to each telephone number". As each SMS costs money, this policy tries only to mitigate the losses incurred by the attacks and does not prevent them.
>
> Nauman et al. (Nauman, Khan, & Zhang, 2010) proposed Apex, a policy enforcement framework, which allows users to impose and define runtime constraints on the usage of resources by the applications. However, there is no discussion about the ability of the defined constraints to prevent the attacks.

DroidForce(Siegfried Rasthofer，Lovat，& Bodden，2014 )，各种策略被应用在Android应用程序上是为了解决收费短信诈骗和数据泄露的问题。然而，不是所有的策略都可以阻止攻击。例如，一个策略可以陈述：“每天不超过两个收费短信会被发送到每一个电话号码。”由于每条短信都需要花钱，这个策略只是试图去减少损失而不是阻止损失。

Nauman(Nauman，Khan，& Zhang，2010)等，提出了Apex，一个策略实施框架。它允许用户对应用程序使用的资源实施和定义运行时约束。但是，并没有关于定义约束来阻止攻击的可能性的描述。

###2.2 Preventive policy enforcing approach

> Almohri et al. (Almohri, Yao, & Kafura, 2014) proposed DroidBarrier, which is a process authentication model for Android. DroidBarrier provides legitimate applications with security credentials that are used when the process associated with the application wants to be authenticated. The processes that do not have the credentials fail during their authentication attempts and their corresponding applications are considered as malicious. The main issue in this model is that the user needs to initially determine which applications are legitiate, which is not easy to be done by an average user.
>
> In Derhab et al.(Derhab,  Saleem, & Youssef, 2014), each SMS application, which is known by the user, is provided with a cryptographic key to encrypt its SMSs. All the SMSs have to pass through a filter at the kernel level before going out of the device. If the filter can correctly decrypt the SMS, it sends the decrypted message to the wireless communication medium. Otherwise, it prevents the SMS from going out of the device and identifies the application, which sent the malicious SMS. However, each SMS application in this solution has to encrypt all its outgoing SMSs, which requires the modification of the application. Also, it incurs additional pro-cessing time and SMS sending time due to encryption and decryption operations.
>
> Xu et al. (Xu, Saïdi, & Anderson, 2012) proposed Aurasium, which automatically repackages an application to attach a user-level policy enforcement code. This code monitors any security violation like: sending SMS to premium numbers. If such a violation occurs, Aurasium displays the phone destination number and the SMS content, and waits for the user to confirm or reject the SMS-sending operation. The major disadvantage of Aurasium is the need to define permissions for each application. In addition, the user has to intervene each time there is an attempt to send SMS.
>
> Sun et al. (Sun, Zheng, Lui,& Jiang, 2014) proposed Patronus, an intrusion prevention system for Android. Patronus defines a list of intrusive transactions that might violate Android security. When there is an attempt to execute a transaction, e.g., sendText, Patronus, using API hooking, suspends the execution of the trans-action and checks the existence of any permission associated with this transaction. If Patronus does not find any rule in the policy database, it notifies the user and displays the transaction content (e.g., SMS content and destination number). The transaction will resume execution when it is allowed by the user. Otherwise, it will be blocked. Although Patronus utilizes a preventive mechanism (i.e., API hooking), there is no discussion about the ability of the policy to prevent all the malicious SMSs.
>
> Sakamoto et al. (Sakamoto, Okuda, Nakatsuka, & Yamauchi,2014) proposed DroidTrack, which notifies the user in case of the possibility of information leakage, i.e., when the application calls an API to collect sensitive information, it then calls another API to communicate externally. The user is alerted and asked to confirm or reject the execution of the API. However, this solution requires user intervention whenever the two APIs are called.
>
> MinDroid (Derhab, Saleem, Youssef, & Guerroumi, 2015) assumes that any malicious application starts sending malicious SMS within T time units after its installation on the mobile device. Based on this assumption, MinDroid requires user intervention only during the first T time units starting from the application installation time. During this time period, the user either confirms or rejects the SMS-sending operations. After the expire of this time, all the known SMS applications are allowed to send SMSs. However, if this assumption is dropped, the SMS is only blocked from appli-cations, which are not known for their SMS-sending activities. MinDroid cannot detect known compromised SMS applications, which only send malicious SMSs after the expire of T.

Almohri(Almohri，Yao，& Kafura)等，提出DroidBarrier，这是一个针对Android的身份验证的过程模型。当与进程相关的应用程序需要被验证的时候，DroidBarrier 会提共带有安全凭证的合法应用。因为没有凭证而在认证尝试过程中认证失败的相应应用将被认为是恶意程序。此模型的主要问题是，用户首先需要确定那些应用程序是合法的，但是这对普通用户来说并不容易。


在Derhab(Derhab，Saleem，& Youssef，2014)等提出的意见中。每一个用户所了解的短息应用中，提供了一组密钥来加密短信。所有短信在发送之前，都必须通过一个内核级别的过滤器。如果这个过滤器能正确解密这条短信，它会将已解密的消息发送到无线通信介质。否则，它会阻止发送这条短息，并标识发送这条恶意信息的应用程序。然而，在这种解决方案中的所有短信应用都必须加密要发送的短信，这将需要短信应用程序进行修改。此外，它会因为要加密和解密要发送的短信而带来额外的处理时间。

Xu(Xu，Saidi，& Anderson， 2012)等提出Aurasium，它会自动重新打包应用程序来附加用户级别的策略执行的代码。这段代码会监控任何安全违规。例如：发送短信到收费的电话号码。如果发生这种违规行为，Aurasium显示电话目的地号码和短信内容，并且等待用户 确认或者拒绝短信发送操作。Aurasium的主要缺点是需要为每个应用程序定义权限。此外，每次有发送短信意图的时候，用户都必须进行干预。

Sun(Sun，Zheng，Lui，& Jiang，2014)等提出了Patronus。这是一个Android入侵防御系统。Patronus定义了一组可能违反Android安全入侵的事物列表。当试图执行一个事务的时候

Sakamoto(Sakamoto，Okuda，Nakatsuka，& Yamauchi，2014)等提出DroidTrack。 在信息可能泄露的情况下它会提醒用户，例如，当应用程序调用API来收集敏感信息，然后调用另一个API和外部通信的时候。用户会被警告并询问确认或者拒绝来执行这个API。然而，当两个API都被调用的时候，这种解决方案仍然需要用户的介入。

MinDroid(Derhab，Saleem，Youssef，& Guerroumi，2015)假定恶意程序在移动设备上安装之后将在T时间单位内发送恶意短信。基于这样的假设，MinDroid仅需要用户在恶意程序安装之后的第一个T时间单位内进行干预。在此期间，用户可以确认或者拒绝短信发送操作。在用户选择或者拒绝的时间到期后，所有已知的短信应用程序将可以发送短信息。然而，这个假设是不完全的，因为只有当那些未知的应用程序发送短信时，短信才会被阻塞。对于只在T单位时间到期后才发送恶意短信的应用程序，MinDroid是无法检测到的。

> The SMS spam detector (Al-Omany, Al-Muhtadi, & Derhab, 2015) only checks the first SMS sent from each application. It shows an alert dialog box that asks the user to confirm whether he/she is the sender of the SMS. If the user confirms, the application will be classified as authorized and the SMS operation will be resumed. Otherwise, it will be classified as malicious. Further SMSs, which are sent by authorized applications, are analyzed by an SMS spam filter. If an SMS is found legitimate, it is allowed to leave the device and a notification about the sent SMS is shown in the notification status bar for any further verification by the user. It might happen that the filter incorrectly classifies an SMS spam as ham, and the SMS in this case cannot be blocked. Although the prevention of all malicious SMSs is impossible, the notification status bar helps the user identify the compromised application, which sends both legitimate and malicious SMS.

垃圾短信检测器(Al-Omany，Al-Muhtadi，& Derhab，2015)只检查应用程序第一次发送的短信。它显示一个警告对话框，并要求用户确认他/她是否是短信的发送者。如果用户确认授权，应用程序将被归类为有权限的一组，并恢复其短信操作权限。否则，它将被归类为恶意。对与授权应用程序发送的短信将有垃圾短信过滤器来进行更进一步的分析。如果发现这条短信是合法的，将会允许其离开设备，并在通知栏显示一条发送的短信的状态用于用户进一步的验证。短信过滤器可能会错误地将垃圾短信归类为电报，在这种情况下，短信发送将不会被阻止。尽管预防所有的恶意短信是不可能的，通知状态栏可以帮助用户识别可以发送合法和恶意短信的应用程序。

##3. System model and basic idea

###3.1 Security model

> We make the following assumptions about OnDroid
>
> 1.Android kernel code is initially secure (i.e., not compromised and free from malicious code).
>
> 2.OnDroid is installed before installing any SMS application.
>
> 3.OnDroid utilizes the Sandboxing feature provided by the Android kernel. This feature enables isolating applications from one another. In Android, each application is assigned a unique user ID (UID) and is run as a separate process. The filesystem access rules do not allow one user (resp., application) to access or modify another user's (application's) files.
>
> 4.An attacker cannot obtain root privileges of the mobile device using the privilege escalation attack. Under this attack, when a malware gets access to the root account, it can bypass the sandboxing protection mechanism, and gain control over the operating system and data. OnDroid prevents this attack by using some solutions like the one presented in (Lee, Kim, & Park, 2014) or by using SELinux-enabled kernel, which is available starting from Android 4.3. In SELinux, data are protected from applications that can access the root user by applying a custom security policy, which specifies the applications that have access to the data (Allalouf, Ben-Av, & Gerdov, 2014).

我们对OnDroid作出以下假设：

1、Android内核代码最初是安全的。(即，不妥协，不受恶意代码威胁);

2、OnDroid先于任何短信应用程序之前安装。

3、OnDroid 利用Android内核提供的沙盒功能，将应用程序相互隔离。Android为每一个应用程序分配了一个用户 ID(UID)，并让应用程序作为一个独立的进程运行。该文件系统的访问权限是不允许用户(指应用程序)访问和修改其他用户(应用程序)的文件发。

4、攻击者无法获得使用权限升级攻击移动设备的root权限。在这种攻击，当一个恶意应用程序获取到root账户访问权限，攻击者就能够绕开沙盒的保护机制，并取得操作系统的控制权和数据。OnDroid通过使用像(Lee，Kim，& Park，2014)提出的或使用被应用在Android4.3中的SELinux内核，来防止这种攻击。在SELinux中，用户可以自定义安全策略，明确指出那些程序能够访问这些数据，从而防止数据被能够获取root权限的应用盗取(Allalouf，Ben-Av，& Gerdov，2014)。

###3.2 Attack model

>An SMS attack is said to be successful if the malicious SMS can go out of the device. We consider two types of SMS attacks:
>
>First attack model: The malicious application hides its SMS-sending activities from the user, and only sends malicious SMSs. Second attack model: The user installs a compromised SMS application, i.e., SMS-sending activities are not hidden from the user, but the application also secretly sends malicious SMSs. This kind of threat happens when an attacker repackages a legitimate application and inserts malicious code into it.

如果恶意短信发送成功，则认为短信攻击是成功的。我们考虑了两种类型的短信攻击：


第一种攻击模型：恶意程序会隐藏自己发送恶意短信的行为，而这种恶意应用程序只发送恶意短信。第二种攻击模式：用户安装了一种折中的短信应用程序，即短信发送不会隐藏，但是应用程序也会偷偷发送恶意短信。这种威胁往往发生在攻击者向一个合法的应用程序插入恶意代码并打包它。

###3.2 User behavior model

> We consider that the user behavior with respect to the mobile device is shaped by two main features.
>
> User availability: This feature has two modes: available and unavailable. The user is said to be available with respect to the mobile device if he/she is near that device, i.e, the user is not faraway from the mobile device and can hear the sound alarms triggered by it. If the user is faraway from the mobile device, he/ she is considered as unavailable. User activity: It defines the actions performed by the user when interacting with the mobile device like: reading information, touching the screen.







