> #

#在Android设备上通过检测用户的行为，来调整预防发出恶意短信

> Abstract: In this paper, we propose OnDroid, a prevention system to defend against outgoing malicious SMS in Android devices. OnDroid is user-friendly as it considers the user's little understanding of the Android system. It also considers multiple threat scenarios and requires less interaction with the user. For each SMS-sending operation , OnDroid first checks if the mobile device state mismatches the user's behavior. If so, the operation is blocked. Otherwise, it is delayed for a while and the user is notified to confirm or reject the operation. If the SMS is considered normal, the user does not need to take any action and the SMS is sent when the delay expires. Efficiency analysis shows that malicious SMS operations might be missed when the user is unavailable. To  deal with this issue, we propose a method by which the user behavior can be adjusted to achieve 100% of malicious SMS prevention. Formal analysis as well as comparative study show that OnDroid offers a good tradeoff between security efficiency and usability.

摘要：在本文中，我们提出了一个Android设备上的、可以防止发出恶意短信的防御系统，并命名为OnDroid。OnDroid 是用户友好的，因为它不仅考虑了用户对Android系统知之甚少，而且考虑了多种和用户交互较少的威胁场景。每次发送短信时，OnDroid 首先检查移动设备的状态是否符合用户行为，如果不符合，则阻塞发送。否则，短信发送将被延迟并通知用户，让用户来确认或者拒绝该操作。如果短信被认为是正常的，则用户不需要采取任何行动，至到延时结束后短信将被发送。`效益分析表明，当用户不可用的时候，发送恶意短信可能会被错过。为了解决这个问题 我们提出了一个方法，通过调整用户的行为，来实现100%的防范恶意短信。正式的分析和比较表明，OnDroid 在安全性和易用性之间取得了良好的平衡。`

> Introduction: The Android operating system is largely popular among mobile device users. According to some several reports (Mawston, July 2014; http://www.idc.com/prodse), Android dominated the Smartphone market with a share of 85% and 82.8% in the second quarter of 2014 and 2015 respectively. Due to this popularity, it has been highly targeted by malware developers, which aim at profiting financially by infecting a large number of mobile devices. A study (Maslennikov, February 2014) has shown that Android acounts for 98.05% of mobile threats. According to F-secure report (Labs, April 2014), 99% of the emerged threats, which were discovered in the first quarter of 2014, were designed to run on the Android operating system. F-secure also reported in 2013 that 81.1% of the mobile malware were financially-motivated and 97.14% of the latter targeted Android OS (Labs, November 2013). Most of the financially-motivated malware perform SMS-sending activities during their attacks. This fact was supported by a report published in 2014 (Labs, April 2014). The report showed that 83% of the Android malwares analyzed by F-secure were performing SMS-sending activities, also called SMS-based attacks. These attacks are charged to the victims's account without his/her consent or knowledge, and can take the following forms:

引言：Android操作系统在移动设备用户中广泛流行。据几份报告(Mawston，2014年7月；http://www.idc.com/prodse)显示，Android在智能手机市场占据主导地位，在2014和2015年的第二季度其市场份额分别为85%和82.8%。归咎于其流行程度，Android 平台    。一项研究(Maslennikov，2014年2月)表明，Android占据移动设备威胁的98.05%。F-secure公司报告(Labs，2014年4月)称，2014年第一季度发现的威胁中，99%为Android操作系统设计的。F-secure公司还报告称，在恶意软件中，81.1%是以金钱为动机的，其97.14%的目标是Android系统(Labs，2013年11月)。大部分的恶意软件通过发送短信来进行攻击行为。这一事实的有力支撑者是一篇2014年刊登的报告（Labs，2014年4月）。该报告显示，F-secure分析的Android 恶意软件中，83%表现为发送短信，也称为基于短信的攻击。这些攻击在没有用户的同意或了解的情况下就得到受害者的账户信息。其攻击方式可以采取以下几种方式：

> * SMS Spam: It is an unsolicited message sent from the compromised mobile device to advertise goods and products. The spammers send instructions to the compromised devices to launch SMS spam campaigns(Cloudmark, March 2014).
>
> * SMS Premium rate fraud: The malware sends an SMS to a premium rate number, which results in transferring costly sums from the user's account to that of the cybercriminal(Labs, April 2014).
>
> * SMS malware propagation: The malware sends an SMS containing links to malicious applications in order to infect the recipient devices.
>
> * SMS privacy attack: Some malware secretly send through SMS sensitive information stored at the device to the attacker such as: bank account, phone identifiers (IMES, IMSI), and GPS location.
>
> * SMS flooding attack: Many unauthorized SMSs are generated to attack a target, which might lead to a Denial-of-Service(Dos) (Traynor et al., 2009)
>
>   ​

垃圾短信：受感染的移动设备会在未经许可的情况下发送短信来宣传一些产品。垃圾短信的控制者发送指令到受感染的设备上，以此来启动和发送垃圾短信(Cloudmark，2014年3月)。


收费短信诈骗：恶意软件发送短信到一个需要收费的号码，这将从用户账户中转走大量资金，从而构成网络犯罪(Labs，2014年4月)。


传播恶意短信：恶意软件发送一条包含有链接到恶意应用的链接的短信，从而感染接受设备。


隐私攻击短信：一些恶意软件通过短信偷偷发送一些存储在用户设备上的敏感信息。例如：银行账户，手机表示(IMES, IMSI)，和位置信息。


短信轰炸：生成很多未经授权的短信去攻击一个目标，而导致服务不可用。(Traynor等，2009)。

> The applications in Android use APIs to access resources such as: telephony, SMS and other network functions. These APIs are protected through a security mechanism called permissions. The application developer must define the list of requested permissions in the AndroidManifest.xml file. To complete the installation process of hte applicaton, the user must grant all the requested permissions. Otherwise, the installations fails. In Android 4.2 (Jelly Bean), when an application tries to send an SMS to a premium-rate number, the user is notified. However, a malware can hide the notification from the user. Starting from Android 4.4 (KitKat), the user has to select only default SMS applications, which is allowed to write to SMS provider and receive SMSs. The other SMS applications can only read the SMS provider and are notified when an SMS is received. However, this configuration cannot completely prevent the SMS attacks. It has been reported in(Labs, April 2014) that 0.1% of the applications, which are received from Google's Play Store, were found malicious. Therefore, a user might download a compromised SMS application that sends both legitimate and malicious SMSs. If the user selects it as default, the malicious SMSs cannot be detected as they cannot be distinguished from the legitimate ones.

Android 应用程序使用api来访问资源，例如：电话、短信和其他网络功能。这些api通过名为权限的安全机制而得到保护。Android应用程序的开发者必须在AndroidManifest.xml 文件中定义需要请求的权限列表。在应用程序的安装过程中，用户必须授予应用程序所请求的权限，否则会安装失败。在Android 4.2(Jelly Bean)中，当一个应用程序试图发送一条短信到需要收费的号码时，用户会得到提醒。但是恶意软件可以隐藏用户的通知。从搭载Android 4.4 开始(KitKat)开始，用户必须选择默认的短信应用，该应用拥有发送短信给短信提供商和接受短信的权限。其他短信应用程序只能读取短信的提供商，并在收到短信的时候得到提示。然而，这种形式任然不能完全防止短信攻击。据报道(Labs，2014年4月)，从谷歌应用商店下载的应用程序中，其中0.1% 被发现具有恶意行为。因此，用户可能下载一个既可以发送合法短信又可以发送恶意短信的折中型应用。如果用户把它选择作为默认应用，则会因为不能区分是恶意短信还是合法短息，而检测不到恶意短信。

> Most of the users have little understanding and knowledge of the Android permission policy. This was confirmed in a survey(Felt et al., 2012), which showed that only 17% of the users look at the requested permissions when installing applications. It has also been observed that developers request more permissions than they actually require(Felt, Chin Hanna, Song, & Wagner, 2011). As legitimate and malicious applications can request the same types of permissions, it is often difficult for the users to determine during the installation process if the requested permissions are harmful or not. To deal with this issue, many complementary security mechanisms have been proposed to detect or prevent malicious activities. These mechanisms offer different levels of security efficiency and different user interaction durations, and sometimes require users to have some knowledge of Android secuity.

大多数用户都对Android的权限策略知之甚少。这已经在一项调查中被证实(Feltd等，2012)，该项调查表明，在安装应用程序时，只有17%的用户会查看应用程序申请的权限。人们还发现，开发者请求的权限比他们实际需要的权限多(Felt，Chin Hanna，Song，& Wagner，2011)。因此合法的和不合法的应用程序的权限请求可能是一致的。所以，用户在应用程序的安装过程中，难以决定其申请的权限是有害的还是无害的。为了处理这个问题，很多互补的安全机制被提出来以检测 和阻止恶意活动。这些安全机制提供不同级别的安全效率和不同的用户交互持续时间，有些时候还需要用户具有一定的Android 相关的安全知识。

> In order to help the user to accurately distinguish between legitimate and malicious SMS applications, we propose OnDroid, a prevention system against outgoing malicious SMSs in Android devices. In this paper, we consider two types of SMS threats: (a) SMSs generated by a malicious application without the users knowledge, and (b) a compromised SMS application that sends both legitimate and malicious SMSs. The main idea of OnDroid is to find any incoherence (or mismatch) between the user behavior and the Android device state.

为了帮助用户准确区分合法和恶意短信应用程序，我们提出了OnDroid。它是一个针对Android设备的防止发送恶意短信的短信防御系统。在本文中，我们考虑两种类型的短信威胁：(a) 未经用户同意，有恶意应用生成的短信，和(b) 即可以发送合法和恶意短信的折中型短信应用。OnDroid的主要方案是，在用户行为和Android设备状态之间找出任意的不相关性(或者不匹配)。

> The main contributions of the paper are as follows:
>
> 1. We determine the main features of the user behavior with respect to the mobile device.
> 2. We identify the main features characterizing the Android device state.
> 3. We propose an algorithm that detects any mismatches between the user behavior and the Android device state when performing SMS-sending operations. This algorithm can prevent the occurrence of the first SMS threat.
> 4. If a match is found, the user has to check that the SMS does not come from the second SMS threat. To do so, we delay the SMS-sending operation and the user is notified to intervene in case the SMS is malicious.
> 5. We analyze the resilience of OnDroid against attacks and evaluate its detection efficiency.
> 6. We propose adjustment rules for the user behavior in order to prevent 100% of malicious SMS operations.
> 7. We provide a comparative study that OnDroid offers a good tradeoff between security efficiency and usability.
>
> The rest of the paper is organized as follows. Section 2 discuses related work. In section 3, we present the system model. The detailed descriptions of OnDroid is given in section 4. Security analysis and efficiency anaysis are provided in section 5 and section 6 respectively. In section 7, we present a performance and usability study of security solutions against SMS malware. Finally, Section 8 concludes the paper with a summary of our contributions.

本文的主要工作如下：

1. 我们确定用户在使用移动设备的主要行为特征。
2. 我们识别的主要特征来描述Android设备的状态。
3. 我们提出了一个算法，可以在进行短信发送动作时，来检测用户行为和Android设备状态之间的任何不匹配。该算法能够在第一时间阻止短信威胁的发生。
4. 如果发现匹配点，用户必须检查短信是否来自第三方的威胁。要做到这一点，我们延迟短信发送操作，并通知用户来干预，从而防止恶意短信。
5. 我们分析OnDroid的的应变能力和抵御攻击的能力，并评估其检测效率。
6. 为了100%的防止恶意短信，我们提出了用户行为调整规则。
7. 我们提供了一份比较性的研究，改研究表明OnDroid在安全效率和易用性之间取得了一个良好的平衡。

本文的其余部分安排如下：第二节中谈论了相关工作。在第三节中，我们提出了系统模型。OnDroid详细描述在第四节给出。安全分析和效率分析在第五节和第六节。第七节中，我们针对恶意软件提出了一个可用性研究和性能的安全解决方案。最后，第八节中总结本文和我们提供的资料摘要。

##2. Related Work

> The main existing approaches to detect an installed SMS malware on an Android device can be categorized into: static analysis and dynamic analysis. In the static analysis approaches, the application static information (i.e., program syntax, structural properties), which are extracted from the source or the binary code, are used to check if the application contains malicious code. However, obfuscation techniques can be used to avoid detection. In the dynamic approaches, the application behavior is observed during its execution to detect if there are any inconsistencies with the normal behavior. The problem with this approach is its computational cost and the possibility of evading the detection.

现有的检测在Android设备上安装的恶意短信软件的方法主要分为静态分析和动态分析两类。在静态分析方法中，通过从源码或者二进制代码中提取该应用程序的静态信息(既，程序语法，结构属性)，然后检查是否含有恶意代码。然而，模糊技术可以避免检测。在动态方法中，应用程序在起执行过程中的行为一直处于被监视的状态，从而可以检测其是否有什么异常行为。这种方法的问题是它的计算成本和逃避检测的可能性。

> In anoter category of approaches, called policy enforcement, the behavior of a legitimate application is supposed to follow certain predefined rules. If  a rule violation is found, the application is considered as malicious. The policy enforcing approaches are divided into mitigating and preventive.
>
> The mitigating approach cannot prevent the attack but only detect it, as the rule violation can only be observed after the attack has been carried out. On the other hand, the preventive approach can prevent the occurrence of the attack.

被称为策略执行的另一类方法中，一个合法的应用程序的行为应该是遵循预定义的规则的。如果发现违反规则，则该应用程序被认为是恶意的。实施的办法的政策分为缓解和预防。

缓解方法不能阻止攻击但是能够检测恶意行为，因为攻击之后才能观察到违反的规则。另一方面，预防方法可以防止攻击的发生。

###2.1 Mitigating policy enforcement approach

> In DroidForce (Siegfried Rasthofer, Lovat, & Bodden, 2014), policies are enforced on Android applications in order to deal with the SMS premium rate fraud and data leakage. However, not all policies can prevent the attacks. For example, one policy could state that "no more than two premium-rate messages per day might be sent to each telephone number". As each SMS costs money, this policy tries only to mitigate the losses incurred by the attacks and does not prevent them.
>
> Nauman et al. (Nauman, Khan, & Zhang, 2010) proposed Apex, a policy enforcement framework, which allows users to impose and define runtime constraints on the usage of resources by the applications. However, there is no discussion about the ability of the defined constraints to prevent the attacks.

DroidForce(Siegfried Rasthofer，Lovat，& Bodden，2014 )，各种策略被应用在Android应用程序上是为了解决收费短信诈骗和数据泄露的问题。然而，不是所有的策略都可以阻止攻击。例如，一个策略可以陈述：“每天不超过两个收费短信会被发送到每一个电话号码。”由于每条短信都需要花钱，这个策略只是试图去减少损失而不是阻止损失。

Nauman(Nauman，Khan，& Zhang，2010)等，提出了Apex，一个策略实施框架。它允许用户对应用程序使用的资源实施和定义运行时约束。但是，并没有关于定义约束来阻止攻击的可能性的描述。

###2.2 Preventive policy enforcing approach

> Almohri et al. (Almohri, Yao, & Kafura, 2014) proposed DroidBarrier, which is a process authentication model for Android. DroidBarrier provides legitimate applications with security credentials that are used when the process associated with the application wants to be authenticated. The processes that do not have the credentials fail during their authentication attempts and their corresponding applications are considered as malicious. The main issue in this model is that the user needs to initially determine which applications are legitiate, which is not easy to be done by an average user.
>
> In Derhab et al.(Derhab,  Saleem, & Youssef, 2014), each SMS application, which is known by the user, is provided with a cryptographic key to encrypt its SMSs. All the SMSs have to pass through a filter at the kernel level before going out of the device. If the filter can correctly decrypt the SMS, it sends the decrypted message to the wireless communication medium. Otherwise, it prevents the SMS from going out of the device and identifies the application, which sent the malicious SMS. However, each SMS application in this solution has to encrypt all its outgoing SMSs, which requires the modification of the application. Also, it incurs additional pro-cessing time and SMS sending time due to encryption and decryption operations.
>
> Xu et al. (Xu, Saïdi, & Anderson, 2012) proposed Aurasium, which automatically repackages an application to attach a user-level policy enforcement code. This code monitors any security violation like: sending SMS to premium numbers. If such a violation occurs, Aurasium displays the phone destination number and the SMS content, and waits for the user to confirm or reject the SMS-sending operation. The major disadvantage of Aurasium is the need to define permissions for each application. In addition, the user has to intervene each time there is an attempt to send SMS.
>
> Sun et al. (Sun, Zheng, Lui,& Jiang, 2014) proposed Patronus, an intrusion prevention system for Android. Patronus defines a list of intrusive transactions that might violate Android security. When there is an attempt to execute a transaction, e.g., sendText, Patronus, using API hooking, suspends the execution of the trans-action and checks the existence of any permission associated with this transaction. If Patronus does not find any rule in the policy database, it notifies the user and displays the transaction content (e.g., SMS content and destination number). The transaction will resume execution when it is allowed by the user. Otherwise, it will be blocked. Although Patronus utilizes a preventive mechanism (i.e., API hooking), there is no discussion about the ability of the policy to prevent all the malicious SMSs.
>
> Sakamoto et al. (Sakamoto, Okuda, Nakatsuka, & Yamauchi,2014) proposed DroidTrack, which notifies the user in case of the possibility of information leakage, i.e., when the application calls an API to collect sensitive information, it then calls another API to communicate externally. The user is alerted and asked to confirm or reject the execution of the API. However, this solution requires user intervention whenever the two APIs are called.
>
> MinDroid (Derhab, Saleem, Youssef, & Guerroumi, 2015) assumes that any malicious application starts sending malicious SMS within T time units after its installation on the mobile device. Based on this assumption, MinDroid requires user intervention only during the first T time units starting from the application installation time. During this time period, the user either confirms or rejects the SMS-sending operations. After the expire of this time, all the known SMS applications are allowed to send SMSs. However, if this assumption is dropped, the SMS is only blocked from appli-cations, which are not known for their SMS-sending activities. MinDroid cannot detect known compromised SMS applications, which only send malicious SMSs after the expire of T.

Almohri(Almohri，Yao，& Kafura)等，提出DroidBarrier，这是一个针对Android的身份验证的过程模型。当与进程相关的应用程序需要被验证的时候，DroidBarrier 会提共带有安全凭证的合法应用。因为没有凭证而在认证尝试过程中认证失败的相应应用将被认为是恶意程序。此模型的主要问题是，用户首先需要确定那些应用程序是合法的，但是这对普通用户来说并不容易。


在Derhab(Derhab，Saleem，& Youssef，2014)等提出的意见中。每一个用户所了解的短息应用中，提供了一组密钥来加密短信。所有短信在发送之前，都必须通过一个内核级别的过滤器。如果这个过滤器能正确解密这条短信，它会将已解密的消息发送到无线通信介质。否则，它会阻止发送这条短息，并标识发送这条恶意信息的应用程序。然而，在这种解决方案中的所有短信应用都必须加密要发送的短信，这将需要短信应用程序进行修改。此外，它会因为要加密和解密要发送的短信而带来额外的处理时间。

Xu(Xu，Saidi，& Anderson， 2012)等提出Aurasium，它会自动重新打包应用程序来附加用户级别的策略执行的代码。这段代码会监控任何安全违规。例如：发送短信到收费的电话号码。如果发生这种违规行为，Aurasium显示电话目的地号码和短信内容，并且等待用户 确认或者拒绝短信发送操作。Aurasium的主要缺点是需要为每个应用程序定义权限。此外，每次有发送短信意图的时候，用户都必须进行干预。

Sun(Sun，Zheng，Lui，& Jiang，2014)等提出了Patronus。这是一个Android入侵防御系统。Patronus定义了一组可能违反Android安全入侵的事物列表。当试图执行一个事务的时候

Sakamoto(Sakamoto，Okuda，Nakatsuka，& Yamauchi，2014)等提出DroidTrack。 在信息可能泄露的情况下它会提醒用户，例如，当应用程序调用API来收集敏感信息，然后调用另一个API和外部通信的时候。用户会被警告并询问确认或者拒绝来执行这个API。然而，当两个API都被调用的时候，这种解决方案仍然需要用户的介入。

MinDroid(Derhab，Saleem，Youssef，& Guerroumi，2015)假定恶意程序在移动设备上安装之后将在T时间单位内发送恶意短信。基于这样的假设，MinDroid仅需要用户在恶意程序安装之后的第一个T时间单位内进行干预。在此期间，用户可以确认或者拒绝短信发送操作。在用户选择或者拒绝的时间到期后，所有已知的短信应用程序将可以发送短信息。然而，这个假设是不完全的，因为只有当那些未知的应用程序发送短信时，短信才会被阻塞。对于只在T单位时间到期后才发送恶意短信的应用程序，MinDroid是无法检测到的。

> The SMS spam detector (Al-Omany, Al-Muhtadi, & Derhab, 2015) only checks the first SMS sent from each application. It shows an alert dialog box that asks the user to confirm whether he/she is the sender of the SMS. If the user confirms, the application will be classified as authorized and the SMS operation will be resumed. Otherwise, it will be classified as malicious. Further SMSs, which are sent by authorized applications, are analyzed by an SMS spam filter. If an SMS is found legitimate, it is allowed to leave the device and a notification about the sent SMS is shown in the notification status bar for any further verification by the user. It might happen that the filter incorrectly classifies an SMS spam as ham, and the SMS in this case cannot be blocked. Although the prevention of all malicious SMSs is impossible, the notification status bar helps the user identify the compromised application, which sends both legitimate and malicious SMS.

垃圾短信检测器(Al-Omany，Al-Muhtadi，& Derhab，2015)只检查应用程序第一次发送的短信。它显示一个警告对话框，并要求用户确认他/她是否是短信的发送者。如果用户确认授权，应用程序将被归类为有权限的一组，并恢复其短信操作权限。否则，它将被归类为恶意。对与授权应用程序发送的短信将有垃圾短信过滤器来进行更进一步的分析。如果发现这条短信是合法的，将会允许其离开设备，并在通知栏显示一条发送的短信的状态用于用户进一步的验证。短信过滤器可能会错误地将垃圾短信归类为电报，在这种情况下，短信发送将不会被阻止。尽管预防所有的恶意短信是不可能的，通知状态栏可以帮助用户识别可以发送合法和恶意短信的应用程序。

##3. System model and basic idea

###3.1 Security model

> We make the following assumptions about OnDroid
>
> 1.Android kernel code is initially secure (i.e., not compromised and free from malicious code).
>
> 2.OnDroid is installed before installing any SMS application.
>
> 3.OnDroid utilizes the Sandboxing feature provided by the Android kernel. This feature enables isolating applications from one another. In Android, each application is assigned a unique user ID (UID) and is run as a separate process. The filesystem access rules do not allow one user (resp., application) to access or modify another user's (application's) files.
>
> 4.An attacker cannot obtain root privileges of the mobile device using the privilege escalation attack. Under this attack, when a malware gets access to the root account, it can bypass the sandboxing protection mechanism, and gain control over the operating system and data. OnDroid prevents this attack by using some solutions like the one presented in (Lee, Kim, & Park, 2014) or by using SELinux-enabled kernel, which is available starting from Android 4.3. In SELinux, data are protected from applications that can access the root user by applying a custom security policy, which specifies the applications that have access to the data (Allalouf, Ben-Av, & Gerdov, 2014).

我们对OnDroid作出以下假设：

1、Android内核代码最初是安全的。(即，不妥协，不受恶意代码威胁);

2、OnDroid先于任何短信应用程序之前安装。

3、OnDroid 利用Android内核提供的沙盒功能，将应用程序相互隔离。Android为每一个应用程序分配了一个用户 ID(UID)，并让应用程序作为一个独立的进程运行。该文件系统的访问权限是不允许用户(指应用程序)访问和修改其他用户(应用程序)的文件发。

4、攻击者无法获得使用权限升级攻击移动设备的root权限。在这种攻击，当一个恶意应用程序获取到root账户访问权限，攻击者就能够绕开沙盒的保护机制，并取得操作系统的控制权和数据。OnDroid通过使用像(Lee，Kim，& Park，2014)提出的或使用被应用在Android4.3中的SELinux内核，来防止这种攻击。在SELinux中，用户可以自定义安全策略，明确指出那些程序能够访问这些数据，从而防止数据被能够获取root权限的应用盗取(Allalouf，Ben-Av，& Gerdov，2014)。

###3.2 Attack model

>An SMS attack is said to be successful if the malicious SMS can go out of the device. We consider two types of SMS attacks:
>
>First attack model: The malicious application hides its SMS-sending activities from the user, and only sends malicious SMSs. Second attack model: The user installs a compromised SMS application, i.e., SMS-sending activities are not hidden from the user, but the application also secretly sends malicious SMSs. This kind of threat happens when an attacker repackages a legitimate application and inserts malicious code into it.

如果恶意短信发送成功，则认为短信攻击是成功的。我们考虑了两种类型的短信攻击：


第一种攻击模型：恶意程序会隐藏自己发送恶意短信的行为，而这种恶意应用程序只发送恶意短信。第二种攻击模式：用户安装了一种折中的短信应用程序，即短信发送不会隐藏，但是应用程序也会偷偷发送恶意短信。这种威胁往往发生在攻击者向一个合法的应用程序插入恶意代码并打包它。

###3.2 User behavior model

> We consider that the user behavior with respect to the mobile device is shaped by two main features.
>
> User availability: This feature has two modes: available and unavailable. The user is said to be available with respect to the mobile device if he/she is near that device, i.e, the user is not faraway from the mobile device and can hear the sound alarms triggered by it. If the user is faraway from the mobile device, he/ she is considered as unavailable. 
>
> User activity: It defines the actions performed by the user when interacting with the mobile device like: reading information, touching the screen.
我们认为用户的行为对移动设备有两个主要的特点。

用户可用性：这种特性有两种模式。可用和不可用。如果他/她在移动设备的附近，则用户是可以使用的。移动设备离用户并不远，则可以听到被触发的报警的声音。如果用户离移动设备较远，他/她被认为是不可用。

用户活动：它定义了用户和移动设备交互时执行的操作。如：阅读信息，触摸屏幕。

###4. OnDroid description

> An Android application can send SMSs by invoking one of the three SMS-sending methods of the SmsManager class, which are: sendTextMessage, sendMultipartTextMessage, and sendDataMessage. OnDroid intercepts in real time the calls to SMS-sending APIs. These calls are invoked by applications with the SMS SEND permission, i.e., the AndroidManifest.xml file of the application contains the following line:
>
> <uses  permission android : name
>
> ¼“android:permission:SEND_SMS”= >
>
> The architecture of OnDroid is shown in Fig. 1, and it is composed of the following components:
>
> 1.Known SMS applications: It contains the list of applications, which are known for their SMS-sending activity, and authorized by the user.
>
> 2.API call interception: It intercepts the calls to SMS-sending and suspends the execution of the invoking application.
>
> 3.Policy database: It contains the rules the application must satisfy when an SMS-sending method is invoked, as shown in Table 1.
>
> OnDroid performs the following steps each time the SMS application calls one of the three SMS-sending methods mentioned above:
>
> 1.Suspend the execution of the application (arrow (1) in Fig. 1).
>
> 2.Check if the rule is satisfied.
>
> 3.Block running the application if the rule is violated (arrow (3) in Fig. 1). Otherwise, the SMS-sending is delayed for T time units (arrow (2) in Fig. 1).

Android 应用程序可以通过调用SmsManager类的三个方法来发送短信，这三个方发分别是：sendTextMessage，sendMultipartTextMessage，和sendDataMessage.  OnDroid实时拦截电话发送短信。这些应用调用接口，需要短信发送权限。即这个应用程序的AndroidManifest.xml文件需要包含下面一行：

<uses  permission android : name ¼“android:permission:SEND_SMS”= >

OnDroid的体系结构如图1所示：他是由下列组件构成的：

1. 已知的短信应用程序：它包含应用程序，这是众所周知的SMS发送活动，和授权的用户名单。
2. API调用拦截：它拦截电话和发短信，暂停调用应用程序的执行。
3. 数据策略：它包含当短信发送方法被调用时，应用程序必须满足表1所示的规则。

每次短信应用程序调用上面提到的三种发送短信方法之一的时候，OnDroid都会执行以下的步骤。

1. 暂停应用程序的执行。
2. 检查是否满足对应的规则。
3. 如果正在运行的应用程序违反了规则，则将其阻塞。否则，推迟T时间单位后发送短信。

> Table 1 shows the different rules to apply each time an SMS-sending method is invoked. OnDroid has to check if there are mismatches between the user's behavior and the device state. The normal device state that is coherent with any user, which sends SMS via an SMS application, consists of the following:
>
> Screen state: The screen must be on.
>
> Device lock state: The device must be unlocked.
>
> Application visibility: The application must run in the foreground.
>
> Application status: The application must belong to the Known SMS applications.
>
> If any of the above rules are not satisfied, it means that either the user is not available in front of the device, or there are some ma-licious activities running secretly in the background, or unautho-rized hidden activities running in the foreground application. In this case, OnDroid blocks the SMS-sending operation, as shown in Fig. 2. Any malicious application, which adopts the first attack model, will be blocked by OnDroid. This is due to the fact that the malicious application is hiding its sending activities and it is not authorized by the user to send SMS. Therefore, it will be detected once it performs the first SMS-sending operation.

表1 显示了不同的规则适用于每次有一种发送短信的方法被调用。

OnDroid必须检查是否有用户的行为和设备状态不匹配。正常的设备状态和用户行为是一致的，并且通过SMS应用程序发送短信。正常的设备状态包括以下内容：

屏幕状态：屏幕必须打开。

设备锁定状态：设备必须解锁。

应用可视性：应用程序必须运行在前台。

应用程序状态：应用程序必须属于已知的短信应用。

如果不满足上述的任意规则之一，这就意味着没有任何用户在使用这台设备，或者有恶意应用程序在后台偷偷运行，或者前台应用程序运行未经授权的隐藏活动。在这种情况下，OnDroid阻断短信发送操作。，如图2 所示。任何采用第一种攻击模式的恶意应用程序，都会被OnDroid阻塞。基于这样的事实，恶意应用程序隐藏起短信发送活动，它不能由用户授权的发送短信。因为，它第一次执行短信发送操作时，将会被检测到。

> In case all the above rules are satisfied (i.e., State 9 in Table 1), it means that the user is interacting or recently interacted with the device (i.e., the screen is on, the device is unlocked, and is running an authorized SMS application in foreground). Here, we distinguish two cases.
>
> If the application is legitimate, it only sends SMSs originating from the user.
>
> If the application is compromised, malicious SMSs might be secretly sent while the user is interacting with the application to send his/her legitimate SMSs.
>
> As the defined rules cannot distinguish between legitimate and compromised foreground applications, OnDroid performs the following steps (see Fig. 2):
>
> It delays the SMS-sending operation for T time units. The delay has to be sufficient for the user to intervene if the SMS is malicious.
>
> It notifies the user using two methods:
>
> Displaying a notification in the notification status bar, which allows the user who is interacting with the device to read the notification and disable the application that sent the SMS.
>
> Generating a sound alarm, which allows the user who is avail-able (i.e., near the device) to hear the notification and disable the application that sent the SMS.
> If the user is not available, the attack will stop when the screen becomes off due to user inactivity. When the user interacts again with the device, he/she reads the notification and disables the application that sent the SMS.

在满足上诉所有规则的情况下，这意味着用户正在或者最近与设备交互过。(即，屏幕被点亮，设备没有 被锁上，并且正在前台运行授权的应用程序。)，我们在这儿分两种情况讨论：

如果应用程序是合法的，它只发送来自用户的短信。

如果应用程序是中性的，在用户使用应用程序给他/她发送合法短信的时候，恶意短信可能会被偷偷发送。

如果已经定义的规则不能区分合法的应用和折中的前台应用，OnDroid会执行下面的步骤。

它延迟T个时间单位的短信发送操作。延迟必须足以为用户干预短信是否为恶意短信。

它使用两种方式通知用户：

显示一个通知在状态栏通知，允许用户与设备交互读取通知和禁用应用程序发送短信。产生一个声音警报，它允许可用的用户(或者设备附近的)听到提醒，并禁止应用程序发送短信。

如果用户无法使用，当屏幕因为用户没有操作而关闭时，攻击将会被 停止。当用户与设备再次进行交互， 她/他读取通知并禁用应用程序发送短信。

> The various states assigned to the user and the actions taken by OnDroid in State 9 are illustrated by a Finite State Machine given in Fig. 3. Transitions are labeled with triggering conditions, which need to hold true in order to switch between the states. Each of the states is described below:
>
> ON_Active: In this state, the user is active, i.e., he/she interacting with the mobile device (i.e., the user is active).
>
> ON_Inactive_A: In this state, the screen is still on and the user is inactive (i.e., the user is not interacting with the mobile device) but he/she is able to hear the sound alarms triggered by this device (i.e., the user is available).
>
> ON_Inactive_N: In this state, the screen is still on but the user is faraway from the mobile device and is not able to hear the sound alarms triggered by this device (i.e., the user is not available).
>
> OFF: In this state, the screen is off.
>
> The screen becomes off if the user does not interact with the device for a time period, called inactivity time, which equals the sum of the sojourn time in ON_Inactive_A and ON_Inactive_N states before transiting to OFF. The triggering conditions in the FSM are defined as follows:
> User_IN_A: a predicate that holds true if the user stops inter-acting with the mobile device but he/she is still available.
>
> User_IN_N: a predicate that holds true if the user stops inter-acting with the mobile device and he/she is not available.
>
> User_AC: a predicate that holds true if the user resumes inter-acting with mobile device by transiting from 
>
> ON_Inactive_A or ON_Inactive_N states to ON_Inactive_A.
> User_IN_AN: a predicate that holds true if the user transits from ON_Inactive_A state to ON_Inactive_N state.
>
> ScreenTimeOut: a predicate that holds true if hte screen becomes off after the expiration of the inactivity time.
>
> As described above, OnDroid can prevent the first attack model but it can only detect the second attack model. In the next section, we show how the FSM can be modified to allow as well the prevention of the second attack model.

分配给用户的各种状态和状态9中OnDroid采取的行动在图3的状态转换图说明。转换都表明了转换条件，为了在两种状态之间成功切换，就需要是条件为真。每一种状态描述如下：

ON_Active: 在此状态下，用户是活动的。即，他/她正在与移动设备交互(即用户被激活)。

ON_Active_A: 在这种状态下，屏幕持续保持点亮，并且用户不是活动的(即，用户没有和设备进行交互)。但是，她/他能够听到设备出发的警报声(即，用户是可用的)。

ON_Active_N: 这种状态下，屏幕任然持续保持点亮，但是用户远离了移动设备并且不能听到设备出发的报警声(即，用户不可用)。

OFF: 这种状态下，屏幕是关闭的状态

屏幕会被系统关闭(锁屏)，如果用户一段时间不与设备进行交互，这被称为闲置时间。在屏幕关闭之前，静止时间等于在状态ON_Inactive_A和状态ON_Incative_N逗留的时间之和。在FSM中的转换条件定义如下：

User_IN_A: 一项为真的断定是，用户停止与设备之间的交互，但是他/她任然可用。

User_IN_N: 一项为真的断定是，用户停止与设备之间的交互，他/她是不可用的。

User_AC: 一项为真的断定是，用户继续和设备交互，使ON_Inactive_A状态或者ON_Inactive_N状态变为ON_Inactive_A状态。

User_IN_AN: 一项为真的断定是，用户从状态ON_Inactive_A转换为ON_Inactive_N。

ScreenTimeOut: 如果闲置时间到期后，屏幕会被关闭。